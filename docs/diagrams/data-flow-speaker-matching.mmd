```mermaid
sequenceDiagram
    autonumber
    actor User
    participant CLI as CLI Command
    participant UseCase as MatchSpeakersUseCase
    participant MatchingSvc as SpeakerMatchingService
    participant DomainSvc as SpeakerDomainService
    participant LLM as ILLMService
    participant SpeakerRepo as ISpeakerRepository
    participant PoliticianRepo as IPoliticianRepository
    participant ConvRepo as IConversationRepository
    participant DB as Database

    User->>CLI: polibase update-speakers --use-llm
    activate CLI

    CLI->>UseCase: execute(use_llm=True)
    activate UseCase

    %% Fetch unlinked conversations
    UseCase->>ConvRepo: get_unlinked_conversations()
    activate ConvRepo
    ConvRepo->>DB: SELECT * FROM conversations WHERE speaker_id IS NULL
    DB-->>ConvRepo: unlinked conversations
    ConvRepo-->>UseCase: List[Conversation]
    deactivate ConvRepo

    loop For each conversation
        UseCase->>DomainSvc: normalize_speaker_name(conversation.speaker_text)
        activate DomainSvc
        DomainSvc-->>UseCase: normalized_name
        deactivate DomainSvc

        %% Try to find existing speaker
        UseCase->>SpeakerRepo: find_by_name(normalized_name)
        activate SpeakerRepo
        SpeakerRepo->>DB: SELECT * FROM speakers WHERE name=?
        DB-->>SpeakerRepo: speaker or None
        SpeakerRepo-->>UseCase: Optional[Speaker]
        deactivate SpeakerRepo

        alt Speaker not found
            %% Create new speaker
            UseCase->>DomainSvc: create_speaker(normalized_name, conversation)
            activate DomainSvc
            DomainSvc->>DomainSvc: extract party name
            DomainSvc->>DomainSvc: extract position
            DomainSvc-->>UseCase: new Speaker entity
            deactivate DomainSvc

            UseCase->>SpeakerRepo: save(speaker)
            activate SpeakerRepo
            SpeakerRepo->>DB: INSERT INTO speakers
            DB-->>SpeakerRepo: speaker_id
            SpeakerRepo-->>UseCase: saved Speaker
            deactivate SpeakerRepo
        end

        %% Match speaker to politician (LLM-based)
        UseCase->>MatchingSvc: match_speaker_to_politician(speaker)
        activate MatchingSvc

        MatchingSvc->>PoliticianRepo: search_candidates(speaker.name, speaker.party)
        activate PoliticianRepo
        PoliticianRepo->>DB: SELECT * FROM politicians WHERE...
        DB-->>PoliticianRepo: candidate politicians
        PoliticianRepo-->>MatchingSvc: List[Politician]
        deactivate PoliticianRepo

        alt Has candidates
            MatchingSvc->>LLM: fuzzy_match(speaker, candidates)
            activate LLM
            Note over LLM: LLM determines<br/>best match with<br/>confidence score
            LLM-->>MatchingSvc: match_result (politician_id, confidence)
            deactivate LLM

            alt confidence >= 0.7
                MatchingSvc->>SpeakerRepo: link_to_politician(speaker_id, politician_id)
                activate SpeakerRepo
                SpeakerRepo->>DB: UPDATE speakers SET politician_id=?
                DB-->>SpeakerRepo: updated
                SpeakerRepo-->>MatchingSvc: success
                deactivate SpeakerRepo
            else confidence < 0.7
                Note over MatchingSvc: Low confidence<br/>requires manual review
            end
        end

        MatchingSvc-->>UseCase: matching result
        deactivate MatchingSvc

        %% Link conversation to speaker
        UseCase->>ConvRepo: update_speaker_link(conversation_id, speaker_id)
        activate ConvRepo
        ConvRepo->>DB: UPDATE conversations SET speaker_id=?
        DB-->>ConvRepo: updated
        ConvRepo-->>UseCase: success
        deactivate ConvRepo
    end

    UseCase-->>CLI: MatchingResult(linked=45, created_speakers=12, matched_politicians=8)
    deactivate UseCase

    CLI-->>User: ✓ Linked 45 conversations, created 12 speakers, matched 8 politicians
    deactivate CLI
```

## Speaker Matching Data Flow

This sequence diagram shows how unlinked conversations are matched to speakers and then to politicians using a hybrid rule-based + LLM approach.

### Matching Strategy

#### Phase 1: Speaker Extraction
1. Normalize speaker name from conversation text
2. Search for existing speaker by name
3. Create new speaker if not found

#### Phase 2: Politician Matching
1. Search for politician candidates based on:
   - Name similarity
   - Party affiliation
   - Active period
2. Use LLM for fuzzy matching
3. Link only if confidence ≥ 0.7

### Data Transformations

```
Conversation.speaker_text → Normalized Name → Speaker Entity → Politician Link
```

### Confidence Levels

- **High (≥ 0.9)**: Automatic link
- **Medium (0.7-0.9)**: Automatic link with logging
- **Low (0.5-0.7)**: Manual review required
- **Very Low (< 0.5)**: No match

### Why LLM Matching?

Japanese names in minutes have many variations:
- **Honorifics**: 山田太郎君, 山田議員, 山田太郎
- **Order**: 太郎山田 vs 山田太郎
- **Kanji variants**: 齊藤 vs 斉藤 vs 斎藤

LLM can handle these variations better than simple string matching.
