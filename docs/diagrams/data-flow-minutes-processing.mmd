```mermaid
sequenceDiagram
    autonumber
    actor User
    participant CLI as CLI Command
    participant UseCase as ProcessMinutesUseCase
    participant Storage as IStorageService
    participant LLM as ILLMService
    participant DomainSvc as MinutesDomainService
    participant MeetingRepo as IMeetingRepository
    participant ConvRepo as IConversationRepository
    participant DB as Database

    User->>CLI: polibase process-minutes --meeting-id 123
    activate CLI

    CLI->>UseCase: execute(meeting_id=123)
    activate UseCase

    %% Fetch PDF/Text from GCS
    UseCase->>MeetingRepo: get_meeting(123)
    activate MeetingRepo
    MeetingRepo->>DB: SELECT * FROM meetings WHERE id=123
    DB-->>MeetingRepo: meeting data (with gcs_text_uri)
    MeetingRepo-->>UseCase: Meeting entity
    deactivate MeetingRepo

    UseCase->>Storage: download_text(gcs_text_uri)
    activate Storage
    Storage-->>UseCase: raw text content
    deactivate Storage

    %% LLM Processing
    UseCase->>LLM: divide_into_speeches(raw_text)
    activate LLM
    Note over LLM: Uses Gemini API<br/>with prompt template
    LLM-->>UseCase: speeches_data (JSON)
    deactivate LLM

    %% Domain Logic
    UseCase->>DomainSvc: create_conversations(speeches_data, meeting_id)
    activate DomainSvc

    loop For each speech
        DomainSvc->>DomainSvc: validate speech data
        DomainSvc->>DomainSvc: create Conversation entity
    end

    DomainSvc-->>UseCase: List[Conversation]
    deactivate DomainSvc

    %% Save to Database
    UseCase->>ConvRepo: save_batch(conversations)
    activate ConvRepo

    loop For each conversation
        ConvRepo->>DB: INSERT INTO conversations
        DB-->>ConvRepo: saved
    end

    ConvRepo-->>UseCase: success
    deactivate ConvRepo

    %% Update meeting status
    UseCase->>MeetingRepo: update_processing_status(meeting_id, "completed")
    activate MeetingRepo
    MeetingRepo->>DB: UPDATE meetings SET status='completed'
    DB-->>MeetingRepo: updated
    MeetingRepo-->>UseCase: success
    deactivate MeetingRepo

    UseCase-->>CLI: ProcessingResult(success=True, conversations_count=50)
    deactivate UseCase

    CLI-->>User: ✓ Processed 50 conversations from meeting 123
    deactivate CLI
```

## Minutes Processing Data Flow

This sequence diagram shows the complete flow of processing meeting minutes from PDF/text to structured conversations in the database.

### Key Steps

1. **User initiates processing** via CLI command
2. **Fetch meeting data** from database (includes GCS URI)
3. **Download text** from Google Cloud Storage
4. **LLM processing** divides raw text into individual speeches
5. **Domain validation** creates Conversation entities
6. **Batch save** all conversations to database
7. **Update status** marks meeting as processed

### Data Transformations

```
PDF/Text → Raw Text → LLM JSON → Conversation Entities → Database Records
```

### Error Handling

- If GCS download fails, processing stops
- If LLM API fails, retries with exponential backoff
- If validation fails, invalid speeches are logged and skipped
- Transaction rollback on database save failure

### Performance Considerations

- **Batch processing**: Saves all conversations in a single transaction
- **Async operations**: LLM calls and database operations are async
- **Streaming**: Large texts are processed in chunks
